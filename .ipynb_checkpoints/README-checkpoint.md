![Logo](images/logo.png)
# DemuxNet: Machine Learning Augmented Sample Demultiplexing for scRNA-seq

![GitHub release (latest SemVer)](https://img.shields.io/badge/Version-v1.1.0-yellowgreen) ![GitHub release (latest SemVer)](https://img.shields.io/badge/Language-python-yellowgreen)

DemuxNet is a computational tool designed for single-cell RNA sequencing (scRNA-seq) sample demultiplexing. It automates the assignment of individual cells to their corresponding samples in pooled sequencing runs. By leveraging machine learning algorithms, DemuxNet predicts missing Cell Multiplexing Oligo (CMO) labels for barcodes with incomplete or missing information.

The tool processes sparse single-cell RNA expression matrices in RDS format and trains on known barcodes to resolve sample identities for cells with missing or ambiguous CMO labels.

For more information, please refer to our manuscript: [******].

---

## Table of Contents
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Data Preparation](#data-preparation)
- [Usage](#usage)
  - [Standard Demultiplexing](#standard-demultiplexing)
  - [Attribution & Driver Identification](#attribution--driver-identification)
- [Methodology & Metrics](#methodology--metrics)
- [Contributing](#contributing)
- [License](#license)
- [Contact](#contact)

---

## Prerequisites

Ensure the following dependencies are installed before running DemuxNet:

- **Python**: Version 3.7 or higher.
- **GCC**: Version 7 or higher (required for installing dependencies and ensuring compatibility with the underlying R environment).

---

## Installation

You can install DemuxNet from the source code or via pip.

### Option 1: Install from Source

```bash
git clone [https://github.com/paddi1990/DemuxNet.git](https://github.com/paddi1990/DemuxNet.git)
cd DemuxNet
python setup.py install
```

### Option 2: Install via pip

```bash
pip install demuxnet
```

---

## Data Preparation

DemuxNet requires a sparse single-cell expression matrix in RDS format.

**Recommendation:** Before demultiplexing, filter the cell matrix to retain only high-confidence cells. You can refer to the `assignment_confidence_table.csv` generated by the 10x Cellranger multi pipeline (located at `your/path/to/outs/multi/multiplexing_analysis/assignment_confidence_table.csv`).

Use the following R script to preprocess your scRNA-seq data into the required format:

```R
library(Seurat)
library(deMULTIplex2)
library(dplyr)

# ======= Load Files =======
cmo <- Read10X('/your/path/to/outs/multi/count/raw_feature_bc_matrix/')
cmo_df <- read.csv('your/path/to/outs/multi/multiplexing_analysis/assignment_confidence_table.csv')

# ======= Data Preprocessing ========
# Filter out Blank and Multiplet assignments
filered_cmo_df <- cmo_df %>% filter(!(Assignment %in% c('Blank','Multiplet')))

# Extract cell-gene matrix
cmo_mtx <- cmo$`Gene Expression`[,colnames(cmo$`Gene Expression`) %in% filered_cmo_df$Barcode]
print(dim(cmo_mtx))

# Extract cell-CMO tag information
cmo_tag_mtx <- t(cmo$`Multiplexing Capture`[,filered_cmo_df$Barcode])

# ======= Tagging using Traditional Methods =======
# Perform preliminary classification using deMULTIplex2
cmo_res <- demultiplexTags(cmo_tag_mtx,plot.path = './',plot.name = 'cmo',plot.diagnostics = F)

cmo_assign_table <- cmo_res$assign_table
cmo_assign_table$Barcode <- rownames(cmo_assign_table)

# Create a dataframe with labeled barcodes
cmo_bc_df <- data.frame(Barcode = colnames(cmo_mtx)) %>% 
    left_join(cmo_assign_table[,c("Barcode","final_assign")],by = "Barcode") %>% 
    mutate(barcode = paste(final_assign,Barcode,sep = '_'))

# Check if Barcodes are consistent    
print(identical(colnames(cmo_mtx),cmo_bc_df$Barcode))

# Double check: data shape should match previous output
# Note: Ensure variable names match your environment (e.g., cmo_bc_df)
cmo_mtx <- cmo_mtx[,colnames(cmo_mtx) %in% cmo1_bc_df$Barcode]
print(dim(cmo_mtx))

# Replace with labeled Barcodes
colnames(cmo_mtx) <- cmo_bc_df$barcode

# ====== Save Data =========
saveRDS(cmo_mtx,'your/path/to/cmo_mtx.rds')
```

**Example Matrix Format:**

```text
                   CMO303_AAACCCAAGCACTCCG-1 CMO301_AAACCCAAGCGATGCA-1
ENSONIG00000018423                     .                          .
ENSONIG00000032772                     .                          .
ENSONIG00000007536                     .                          .
ENSONIG00000033498                     .                          .
```

---

## Usage

DemuxNet supports two primary workflows:
1.  **Standard Demultiplexing:** Predicts missing CMO labels for cells.
2.  **Attribution & Driver Identification:** Identifies key gene drivers for cell state classification using Integrated Gradients.

### Standard Demultiplexing

DemuxNet automatically detects the "CMO" keyword within barcode strings for training. For barcodes missing this information, the model predicts and fills in the CMO class.

Run the following command:

```bash
demuxnet -i gene_expression_matrix.rds -model DNN -feature 6000 -out prediction.csv
```

#### Parameters

* **`-i`**: Path to the input sparse single-cell RNA expression matrix (RDS format). Rows represent genes; columns represent cells.
* **`-model`**: The machine learning model for prediction. Currently supports `DNN` (Deep Neural Network).
* **`-feature`**: The number of top features (genes) to select based on non-zero counts. Tune this based on dataset size and complexity.
* **`-out`**: Path for the output CSV file. Contains two columns: "Barcode" and "Predicted CMO Label".

### Attribution & Driver Identification
![[DemuxNet_Gene_Countribution_wf.png]]

This framework uses DemuxNet and Integrated Gradients (IG) to quantify gene contribution to cell classification. It introduces the **WIS** (Weighted Importance Score) and **DCS** (Directional Consistency Score) metrics to identify robust driver genes.

#### Attribution Data Preparation

Prepare a raw count matrix with labels. Replace specific sample information with generic CMO labels and prefix the barcodes.

```R
library(dplyr)
library(Seurat)
library(stringr)

sc <- readRDS('path/to/your/sc.rds')

# Extract raw counts matrix and metadata
count_matrix <- GetAssayData(sc, assay = "RNA", slot = "counts")
meta_data <- sc@meta.data

# Create new Seurat object
sc1 <- CreateSeuratObject(counts = count_matrix, meta.data = meta_data)

# Modify Barcodes: Add labels
sc1@meta.data$Barcode <- rownames(sc1@meta.data)
sc1@meta.data <- sc1@meta.data %>%
  mutate(
    new_Barcode = case_when(
      str_detect(Tissue, "HT") ~ paste0("CMO301_", str_replace(Barcode, ".*_", "")),
      str_detect(Tissue, "NT") ~ paste0("CMO302_", str_replace(Barcode, ".*_", "")),
      TRUE ~ str_replace(Barcode, ".*_", "")
    )
  )

# Rename cells
sc1 <- RenameCells(sc1, new.names = sc2@meta.data$new_Barcode)

# Extract counts layer
counts_matrix <- LayerData(
    object = sc1,
    assay = "RNA",
    layer = 'counts'
)

# Save as RDS
saveRDS(counts_matrix, file = 'sc_counts.rds')
```

#### Run Attribution Analysis

```bash
python demuxnet/ig.py \
  -i test.rds \
  --features 2000 \
  --feature-mode hvg \
  --gene-list Custom.csv \
  --gene-mode all \
  --ig-output ig/ig_summary.csv \
  --randomize-runs 3 \
  --label-map-file label_map.csv \
  --prediction-output-prefix preds/run \
  --accuracy-output ig/accuracy.csv
```

**Workflow Description:**
This command reads the input matrix, selects the top 2000 Highly Variable Genes (HVGs), and merges them with a custom gene list. It trains the DemuxNet DNN model across 3 independent runs. In each run, the dataset is randomly split into training and testing sets (labels are masked based on `label_map.csv`).

#### Attribution Parameters

* **`-i`**: Path to the input gene expression matrix (RDS).
* **`--features`**: Number of top features to select (default: 6000).
* **`--feature-mode`**: Selection mode: `nonzero` (default) or `hvg` (scanpy highly variable genes).
* **`--gene-list`**: Optional CSV/TXT file containing specific feature genes to include.
* **`--gene-mode`**: `only` (use only genes from gene-list) or `all` (union of selected features and gene-list).
* **`--ig-output`**: Path to save the Integrated Gradients attribution summary (CSV).
* **`--randomize-runs`**: Number of independent random label replacement runs. Set to 0 to use original data once.
* **`--label-map-file`**: CSV mapping original CMO labels to replacement labels.
* **`--prediction-output-prefix`**: Prefix for prediction output CSVs.
* **`--accuracy-output`**: Path to save validation accuracy summary.

#### Attribution Output Structure

```text
.
├── accuracy.csv                    # Accuracy metrics for each run
├── ig_summary_run1_pred.csv        # IG attribution based on predicted labels
├── ig_summary_run1_true.csv        # IG attribution based on true labels
├── ig_summary_run2_pred.csv
├── ig_summary_run2_true.csv
...
└── preds                           # Prediction results for split test sets
    ├── run_run1_prediction.csv
    ├── run_run2_prediction.csv
    └── run_run3_prediction.csv
```

**File Details:**

* `accuracy.csv`:
    ```csv
    run,accuracy,balanced_accuracy
    1,0.986,0.956
    2,1.0,1.0
    ```
* `ig_summary_runX_true.csv`: Contains gene contribution scores.
    ```csv
    gene,mean_abs_attribution,mean_attribution
    ENSONIG00000002418,0.486,0.312
    ```
* `preds/run_runX_prediction.csv`: Contains label predictions.
    ```csv
    ,label,source
    CMO301_AAACCCAAGACCACGA-1,CMO301,annotation
    HT_AACCAACGTGTGAGCA-1,CMO301,prediction
    ```

---

## Methodology & Metrics

To mitigate the stochasticity of deep learning models in single runs and the scale variance across converged models, DemuxNet introduces two core metrics—**WIS** and **DCS**. These metrics leverage ensemble learning to identify robust biological driver genes from Integrated Gradients (IG) data.

### 1. Weighted Importance Score (WIS)

**Definition:**
WIS measures the comprehensive ranking score of a gene's contribution to classification decisions across multiple random runs. It acts as an automatic denoiser by assigning higher weights to high-accuracy models.

**Calculation:**
1.  **Rank Normalization:** Convert absolute IG values to a reverse rank ($Rank_{i,k}$) to eliminate scale differences.
2.  **Accuracy Weighting:** Calculate model weight ($W_k$) using the Balanced Accuracy ($Acc_k$) of the test set.

**Formulas:**

* **Model Weight ($W_k$):**
    $$W_k = \left( \max\left(0, 2 \times (Acc_k - 0.5)\right) \right)^2$$
    *(Note: Weights random guesses ($0.5$) to 0 and non-linearly rewards high accuracy.)*

* **Single Run Rank Score ($S_{i,k}$):**
    $$S_{i,k} = 1 - \frac{Rank_{i,k}}{M}$$
    *(Where $M$ is total features and $Rank_{i,k}$ is the absolute rank of gene $i$ in run $k$.)*

* **Final WIS:**
    $$WIS_i = \frac{\sum_{k=1}^{N} (S_{i,k} \times W_k)}{\sum_{k=1}^{N} W_k}$$

### 2. Directional Consistency Score (DCS)

**Definition:**
DCS measures the stability of a gene's regulation direction (e.g., HT vs NT) across runs. It distinguishes stable "Drivers" from fluctuating "Noise".

**Calculation:**
1.  **Sign Extraction:** Extract the sign (+1 or -1) of the gene's IG value in each run.
    * $+1$: Pro-HT / Upregulated in HT context.
    * $-1$: Pro-NT / Barrier to HT.
2.  **Weighted Average:** Calculate the weighted average using model weights ($W_k$).

**Formula:**

$$DCS_i = \frac{\sum_{k=1}^{N} (\text{sign}(IG_{i,k}) \times W_k)}{\sum_{k=1}^{N} W_k}$$

**Interpretation:**
* **$DCS \approx 1$**: Stable Positive Driver.
* **$DCS \approx -1$**: Stable Negative Driver.
* **$|DCS| \le 0.5$**: Ambiguous / Noise.

### 3. Screening Strategy

We recommend using a **Quadrant Plot** to filter final targets:
* **X Axis**: DCS (Directional Stability)
* **Y Axis**: WIS (Importance Rank)
* **Filter**: Retain genes with $|DCS| > 0.5$ and high WIS rank as **"Hidden Drivers"** for downstream enrichment analysis.

---

## Contributing

We welcome contributions! Please submit a pull request for improvements. For major changes, please open an issue first to discuss the proposed modification.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Contact

DemuxNet is maintained by the Hu Lab. For questions or issues, please open an issue on the GitHub repository.

If you use DemuxNet in your research, please cite:
> [******]